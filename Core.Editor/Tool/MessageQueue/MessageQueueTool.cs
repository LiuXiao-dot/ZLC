using System.Reflection;
using Sirenix.OdinInspector;
using UnityEditor;
using UnityEngine;
using ZLC.ConfigSystem;
using ZLC.EditorSystem;
using ZLC.EventSystem.MessageQueue;
using FilePathAttribute = ZLC.FileSystem.FilePathAttribute;
namespace ZLCEditor.Tool.MessageQueue
{
    /// <summary>
    /// 消息队列代码生成
    /// </summary>
    [FilePath("MessageQueueTool.asset", FilePathAttribute.PathType.XWEditor,true)]
    [Tool("消息队列")]
    public class MessageQueueTool : SOSingleton<MessageQueueTool>
    {
        [ShowInInspector][ValueDropdown("CheckType")] public Type[] messages;

        [Button("生成消息队列代码")]
        public void GenerateAll()
        {
            var temp = new List<Type>();
            ToolHelper.GetAllMarkedType<MessageQueueAttribute>(temp,ToolHelper.AssemblyFilterType.Custom | ToolHelper.AssemblyFilterType.Internal);
            messages = temp.ToArray();
            EditorUtility.SetDirty(this);
            if (messages == null) return;
            foreach (var message in messages)
            {
                if (message == null) continue;
                CreateScript(message);
            }
        }

        private void CreateScript(Type enumType)
        {
            var typeText = enumType.Name;
            var className = $"{typeText}Queue";
            var messageQueueAttribute = CustomAttributeExtensions.GetCustomAttribute<MessageQueueAttribute>(enumType) as MessageQueueAttribute;
            var isMain = messageQueueAttribute.isMainThread;
            var namespaceText = enumType.Namespace;
            var initText = $"var newObject = new GameObject(\"{className}\");";
            var parent = isMain
                ? $"AMainThreadMessageQueue<{typeText}>"
                : $"AChildThreadMessageQueue<{typeText}>";
            var path = (AssetDatabase.FindAssets($"t:Script {typeText}").Select(AssetDatabase.GUIDToAssetPath).First(temp => Path.GetFileName(temp) == $"{typeText}.cs"));
            var dir = Path.GetDirectoryName(path);
            
            var messageQueueText = @$"// <auto-generated/>
using UnityEngine;
using XWEngine;
namespace {namespaceText}{{
    public class {className} : {parent}
    {{
        public static {className} Instance
        {{
            get{{
                if(_instance == null)
                {{
                    {initText}
                    GameObject.DontDestroyOnLoad(newObject);
                    _instance = newObject.AddComponent<{className}>();
                }}
                return _instance;
            }}
        }}
        private static {className} _instance;

        public static bool SubscribeS(IGameEventListener<{typeText}> newListener, params {typeText}[] operates)
        {{
            return Instance.Subscribe(newListener, operates);
        }}

        public static bool UnSubscribeS(IGameEventListener<{typeText}> newListener, params {typeText}[] operates)
        {{
            return Instance.UnSubscribe(newListener, operates);
        }}

        public static void SendGameEventS({typeText} operate, object args = null)
        {{
            Instance.SendGameEvent(operate, args);
        }}

        public static void SendGameEventImmediateS({typeText} operate, object args = null)
        {{
            Instance.SendGameEventImmediate(operate, args);
        }}
    }}
}}";
            File.WriteAllText(Path.Combine(dir,$"{className}.cs"), messageQueueText);
            Debug.Log(Path.Combine(dir,$"{className}.cs"));
        }

        public IEnumerable<Type> CheckType()
        {
            var temp = new List<Type>();
            ToolHelper.GetAllMarkedType<MessageQueueAttribute>(temp,ToolHelper.AssemblyFilterType.Custom | ToolHelper.AssemblyFilterType.Internal);
            if (messages != null)
            {
                var old = messages.ToList();
                temp.RemoveAll(temp => old.Exists(temp2 => temp.FullName == temp2.FullName));
            }

            return temp;
        }
    }
}